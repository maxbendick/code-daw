* next graph steps
** create graph in eval

get rid of outputs. the node is the output
output is necessary to differentiate types for the users editing experience

* DONE convert the base to use EdgeTypes instead of Signal|AudioSignal|MidiSignal


* graph advantages
** can use generic algorithms
** UI shouldn't do much
** need a graph anyway
** deserted branches can be found through vars
** can detect cycles (and sometimes allow?)
* graph disadvantages
** dial updates?

* next step ideas
** dials update audio?
** TODO convert to graph based eval, with separate runtime
** organize stuff better
** rename Token to InteractableType
** use sourcemap somehow
** do some actual livecoding for fun
** DONE use new Error().stack to get line number of dial call
*** DONE line = getLineNumber(); var x = window.codeDawVars.x = .....

* hot ideas
** dial can be referenced by variable name!
  const myDial = dial(...) registers a dial with ID 'myDial'?
** dial instances can add themselves to window
** dial zones can add themselves to window through an OO facade
** buses can be added to dials through window
** should be able to keep code for a zone + instance all together

** step eval doesn't start runtime
*** add step for connecting buses, after eval
*** eval adds function to window to start runtime
*** rest of program calls eval

** add all vars to window?
   replace "var myVar = dial(" 
   with    "var myVar = window.codeDawVars.myVar = dial("
*** have to error all dials without assigning to const
*** DONE for all lines with a dial, and dialVarName
    line must start with: `const ${dialVarName} = dial(`
    could simply use this for all parsing with lookahead/lookbehind
*** DONE add dialVarName to token parse result

* Binding brainstorming
** each interactable in runtime has an index
** each coolzone instance knows it's own index?
** need to crossreference coolzone instances with dial instances
   component will get start/end/default
** first, need a basic runtime
** multiple dials on one line -> error in runtime?
** need to error if in loop/function or multiple 
   calls for one call expression 
** can error if token doesn't match interactable runtime function

* Runtime brainstorming
** compile with tsc
** run with eval
** need to add runtime dependencies (audio-signals.js, etc.)
** need to create runtime files
** need cross-communication between evaled files and rest of program
** send dial updates to runtime
** consider messages sent from runtime, like for gain meters
** buses are visible to runtime based off code analysis before eval

** mvp:
*** tsc to compile to JS
*** remove types only?
*** use global eval + window to communicate, share lib
*** remove imports before compilation?
*** configure tsc? tslib? 

** steps
*** DONE make runtime evaluate fine
*** DONE remove types from input code
*** DONE remove imports, add stuff to window based on imports
*** DONE eval code in browser
*** TODO connect core buses
*** DONE inject dials into cool zones


* Future
** use ts language service for highlighting, binding
** sanitize input code
** convert imports to declaring from window?
** cache parsing results

* NEXT STEPS
** save changes
** in text editor, make code that exports an audionode
** an audiocontext can be added to window for the editor to use
** run the audio node
* after that
** es import for audiocontext
** interactables
** multiple files


* current task
** working on porting to commonjs modules
** make attaching coolzones to interactables optional
* after currentt work
** get line num by looking for export assignement in sourcemap
** disallow import errors
** move to esmodules? need a way to adapt codeDawRequire
   
   const codeDawPackage = `
      export const sine = window.codeDawRequire('oscillators').sine
      export const saw =  window.codeDawRequire('oscillators').saw
      export const simpleSequencer =  window.codeDawRequire('sequencers').simpleSequencer
   `.encode()

   codeWithImports = code.replace('from "code-daw"', `from "${codeDawPackage}"`)

   import(codeWithImports.encode()).then(module => {
      console.log('created module!')
   })


   const statefulDial = ()

   const myCustomInteractable = createInteractable(
      (args) => {
         return {
            markup: <div>{args.myName}</div>
            output: Signal.of(args.myConstant)
         }
      },
   )

* next steps
** DONE global volume dial
** DONE pretty dial
** DONE revisit coolzone attachment
** DONE ctrl/shift-enter to compile, attach elements, run
** DONE save code on compile, reset code
** DONE runtime creates audio context, which is destroyed without click on exit
** DONE can toggle between runtime and editing
** DONE put coolzone component inside superdef ðŸ¤¯
** DONE coolzone can choose which components to render
** TODO document (compilation, parsing tokens, attaching zones, codeDawVars)
** TODO map between nodetype and token? 
*** can have superdef define token?
*** link with one namespace
** TODO consider moving to one namespace only?
** DONE split frequncy and fm
** TODO fix dials
** TODO reverb
** TODO re-eval expressions
** TODO use exports for dials/interactables? DING DING DING
** TODO what level do updates happen? Eval everything? Eval expression? Eval export?
** TODO making interactables in-app?
** TODO to fill out library - after iterating on basics, bootstrap from low-level?
** TODO consider plugin architecture? observable<serializable>-based api-clients?

* brainstorming next steps
** make superdef registry adhoc?
** live coding
** interactables (start with a function)
*** switch
*** very basic sequencer
*** mixer
*** tuner
** functions
*** signal map for user


* later
** hook into devserver refresh for lifecycle?
** setup and teardown of window vars
** organization of window vars
** make signal graph basically callstack only
** automated tests

* offtopic
** could make blog post about types only used for deviation
   interface Dong { thing: any }
   const myDong = { thing: 'on' } as const
   const _proof: Dong = myDong // nice for development
   const getThing: <D extends Dong>() => Dong['thing']

** DONE create actual dial component ( ish ;) )
** DONE create sine
** DONE create masterOut

* DONE next graph steps
** DONE create graph in eval

get rid of outputs. the node is the output
output is necessary to differentiate types for the users editing experience

* DONE convert the base to use EdgeTypes instead of Signal|AudioSignal|MidiSignal


* graph advantages
** can use generic algorithms
** UI shouldn't do much
** need a graph anyway
** deserted branches can be found through vars
** can detect cycles (and sometimes allow?)
* graph disadvantages
** dial updates?

* next step ideas
** DONE dials update audio?
** DONE convert to graph based eval, with separate runtime
** DONE organize stuff better
** rename Token to InteractableType
** use sourcemap somehow
** do some actual livecoding for fun
** DONE use new Error().stack to get line number of dial call
*** DONE line = getLineNumber(); var x = window.codeDawVars.x = .....

* hot ideas
** DONE dial can be referenced by variable name!
  const myDial = dial(...) registers a dial with ID 'myDial'?
** DONE dial instances can add themselves to window
** dial zones can add themselves to window through an OO facade
** buses can be added to dials through window
** should be able to keep code for a zone + instance all together

** DONE step eval doesn't start runtime
*** add step for connecting buses, after eval
*** DONE rest of program calls eval

** TODO add all vars to window?
   replace "var myVar = dial(" 
   with    "var myVar = window.codeDawVars.myVar = dial("
*** have to error all dials without assigning to const
*** DONE for all lines with a dial, and dialVarName
    line must start with: `const ${dialVarName} = dial(`
    could simply use this for all parsing with lookahead/lookbehind
*** DONE add dialVarName to token parse result

* Binding brainstorming
** DONE each interactable in runtime has an index
** DONE each coolzone instance knows it's own index?
** DONE need to crossreference coolzone instances with dial instances
   component will get start/end/default
** DONE first, need a basic runtime
** multiple dials on one line -> error in runtime?
** need to error if in loop/function or multiple 
   calls for one call expression 
** can error if token doesn't match interactable runtime function

* Runtime brainstorming
** DONE compile with tsc
** DONE run with eval
** DONE need to add runtime dependencies (audio-signals.js, etc.)
** DONE need to create runtime files
** DONE need cross-communication between evaled files and rest of program
** DONE send dial updates to runtime
** consider messages sent from runtime, like for gain meters
** buses are visible to runtime based off code analysis before eval

** mvp:
*** DONE tsc to compile to JS
*** DONE remove types only?
*** DONE use global eval + window to communicate, share lib
*** DONE remove imports before compilation?
*** DONE configure tsc? tslib? 

** steps
*** DONE make runtime evaluate fine
*** DONE remove types from input code
*** DONE remove imports, add stuff to window based on imports
*** DONE eval code in browser
*** TODO connect core buses
*** DONE inject dials into cool zones


* Future
** use ts language service for highlighting, binding
** sanitize input code
** convert imports to declaring from window?
** cache parsing results
